!==========================================================================================
! Simple Regrowth Object
!==========================================================================================
module MolCon_LinearCBMC
  use CoordinateTypes, only: Perturbation, Addition
  use Template_SimBox, only: SimBox
  use Template_MolConstructor, only: MolConstructor
  use VarPrecision


  type, public, extends(MolConstructor) :: LinearCBMC
    integer :: firstAtom = 1
    integer :: nRosenTrials = 1
!    integer :: inspoints = 1
    real(dp), allocatable :: RosenProb(:)
    real(dp), allocatable :: tempcoords(:, :)
    integer, allocatable :: patharray(:)
    integer, allocatable :: pathposition(:)
    integer, allocatable :: grown(:)
    integer, allocatable :: schedule(:)
    integer, allocatable :: freq(:)
    contains
!      procedure, public, pass :: Constructor => LinearCBMC_Constructor
      procedure, public, pass :: Prologue => LinearCBMC_Prologue
      procedure, public, pass :: GenerateConfig => LinearCBMC_GenerateConfig
      procedure, public, pass :: ReverseConfig => LinearCBMC_ReverseConfig
!      procedure, public, pass :: GetNInsertPoints
  end type
!==========================================================================================
  contains
!==========================================================================================
  subroutine LinearCBMC_Prologue(self)
    use Common_MolInfo, only: MolData, BondData, nMolTypes
    use MolSearch, only: FindBond
    use ParallelVar, only: nout
    implicit none
    class(LinearCBMC), intent(inout) :: self
!    integer, intent(in) :: molType
    integer :: iType, iBond, iAtom, curMax, nAtoms
    integer :: atm1, atm2
    integer :: iError = 0
    integer :: iSchedule
    integer :: nextAtm, prevAtm, curAtm, iPath
    integer ::  leftdist, rightdist, nleft, nright, nfirst

    !Count the number of bonds each atom has.  This will be used to classify the atom
    !as either a Terminal, Linker, or Branch atom. 
    ! nBonds = 0 >> Isolated Atom
    ! nBonds = 1 >> Terminal Atom located on the end of a chain
    ! nBonds = 2 >> Linker Atom.  Located in the middle of a linear chain
    ! nBonds >= 3 >> Branch Atom.  Has two or more potential paths one can wander down.
    nAtoms = MolData(self%molType)%nAtoms
    if(MolData(self%molType)%nAtoms > 1) then
      allocate( self%freq(1:nAtoms) )  
      self%freq = 0
      do iBond = 1, size(MolData(self%molType)%bond)
        atm1 = MolData(self%molType)%bond(iBond)%mem1
        self%freq(atm1) = self%freq(atm1) + 1
        atm2 = MolData(self%molType)%bond(iBond)%mem2
        self%freq(atm2) = self%freq(atm2) + 1
      enddo
    else 
      iError = -1
    endif


    !If any atom has more than 3 bonds it's a branched molecule and not suited for this algorithm.
    if( any(self%freq > 2) ) then
      iError = -1
    endif

    !If there's no terminal atoms the molecule is likely cyclic
    if( all(self%freq /= 1) ) then
      iError = -1
    endif


    !Since this module is for linear molecules, if a branch is detected or
    !the atom is simply an isolated atom throw an error since it is not compatible with.
    !this module
    if(iError /= 0) then
      write(0,*) "Linear CBMC has been invoked on a molecule that is not linear. Stopping Classy."
      stop
    endif

    if(.not. allocated(self%RosenProb)) then
      allocate(self%RosenProb(1:self%nRosenTrials))
      allocate(self%tempcoords(1:3, 1:self%nRosenTrials))
    endif


    !Create the path array which is used to determine regrowth order.
    if(.not. allocated(self%patharray) ) then
        allocate( self%patharray(1:nAtoms) )  
        allocate( self%pathposition(1:nAtoms) )  
        allocate( self%schedule(1:nAtoms) )  
    endif
    self%patharray = 0
    self%pathposition = 0
    !Pick an terminal atom to start building the patharray
    prevAtm = 0
    do iAtom = 1,nAtoms
      if(freq(iAtom) == 1) then
        curatm = iAtom
        exit
      endif
    enddo

    self%patharray(1) = curatm
    self%pathposition(curatm) = 1
    iPath = 1
    ! Begin the building process by traversing from bond to bond.
    do iAtom = 1, nAtoms-1
      nextatm = 0
      do iBond = 1, size(MolData(self%molType)%bond)
        atm1 = MolData(self%molType)%bond(iBond)%mem1
        atm2 = MolData(self%molType)%bond(iBond)%mem2
        if(atm1 == curatm) then
          if(atm2 /= prevatm) then
            nextatm = atm2
            exit
          endif
        endif
        if(atm2 == curatm) then
          if(atm1 /= prevatm) then
            nextatm = atm1
            exit
          endif
        endif
      enddo
!      write(*,*) prevatm, curatm, nextatm
      if(nextatm /= 0) then
         iPath = iPath + 1
         self%patharray(iPath) = nextatm
         self%pathposition(nextatm) = iPath
         prevatm = curatm
         curatm = nextatm
      else
        write(0,*) "Linear CBMC: DEAD END ERROR! There is a problem in the molecule definition!"
        write(0,*) "Ensure your molecule's bonds are properly connected."
        stop
      endif
    enddo


    if(any(self%patharray == 0)) then
      write(0,*) "LINEAR CBMC: ERROR! There are atoms which are unaccounted for by the path building algorithm."
      write(0,*) "Ensure your molecule's bonds are properly connected."
      stop
    endif


!    write(*,*) self%patharray
!    write(*,*) self%pathposition
    ! We now construct the scheduling array which is responsible for determing the order
    ! that the atoms are inserted into the system.  To do this first we determine
    ! after the first atom is inserted into the system
    nfirst = self%pathposition(self%firstAtom)
    leftdist = self%patharray(nfirst) - self%patharray(1)
    rightdist =  self%patharray(nAtoms) - self%patharray(nfirst)
    self%schedule(1) = self%firstAtom
    iSchedule = 1
    if(leftdist > rightdist) then
       do iAtom = nfirst+1, natoms
         iSchedule = iSchedule + 1
         self%schedule(iSchedule) = self%patharray(iAtom)
       enddo
!       do iAtom = 1, nfirst-1, -1
       do iAtom = nfirst-1, 1, -1
         iSchedule = iSchedule + 1
         self%schedule(iSchedule) = self%patharray(iAtom)
       enddo
    else
       do iAtom = nfirst-1, 1, -1
         iSchedule = iSchedule + 1
         self%schedule(iSchedule) = self%patharray(iAtom)
       enddo
       do iAtom = nfirst+1, natoms
         iSchedule = iSchedule + 1
         self%schedule(iSchedule) = self%patharray(iAtom)
       enddo
    endif




  end subroutine
!==========================================================================================
  subroutine LinearCBMC_GenerateConfig(self, trialBox, disp, probconstruct, insPoint, templist, tempNNei)
    use Common_MolInfo, only: MolData, BondData, AngleData, nMolTypes
    use MolSearch, only: FindBond, FindAngle
    use RandomGen, only: Generate_UnitSphere, Generate_UnitCone
    implicit none
    class(LinearCBMC), intent(inout) :: self
    class(Addition), intent(inout) :: disp(:)
    class(SimBox), intent(inout) :: trialBox
    real(dp), intent(in), optional :: insPoint(:)
    real(dp), intent(out) :: probconstruct

    integer :: bondType, angleType, molType
    integer :: iRosen, 
    integer :: atm1, atm2,atm3, iDisp, iAtom
    real(dp), dimension(1:3) :: v1, v2, v3
    real(dp) :: dx, dy, dz, r, theta
    real(dp) :: r1, r2
    real(dp) :: prob
    real(dp) :: ang1, ang2

    probconstruct = 1E0_dp
    select type(disp)
      class is(Addition)
        molType = disp(1)%molType
      class default
        stop "Critical Errror! An invalid perturbation type has been passed into the regrowth function"
    end select

    if(size(insPoint) /= self%nRosenTrials) then
      write(0,*) "ERROR! Linear CBMC Regrowth received a different number of insertion points"
      write(0,*) "than it was expecting!"
      error stop
    endif

    !Weight Insertion Points and chose one of them.
    do iRosen = 1, self%nRosenTrials

    enddo


    !Starting from the first inserted atom, begin growing the second atom by
    !
    Atm1 = self%schedule(nType, 1)
    Atm2 = self%schedule(nType, 2)
    call FindBond(nType, Atm1, Atm2, bondType)
    do iRosen = 1, self%nRosenTrials
      call BondData(bondType) % bondFF % GenerateDist(trialBox%beta,r2, prob)
      call Generate_UnitSphere(dx,dy,dz)
      self%temppos(1, iRosen) = r*dx + disp(Atm1)%x_new 
      self%temppos(2, iRosen) = r*dy + disp(Atm1)%y_new
      self%temppos(3, iRosen) = r*dz + disp(Atm1)%z_new
    enddo

    if(natoms == 2) then
      return
    endif

!    For the third atom we must begin to include the bending angle in choosing its trial positions. The first thing
!    we must consider is if the second regrown atom was a terminal atom or a linker atom. If it was a terminal atom 
!    then the bending angle must use the 1st atom as the central atom for the angle generation.  
!    However if it was a link in the chain then the 2nd atom regrown should be used as the central atom.
    if(self%freq(Atm2) .eq. 2) then
        Atm1 = self%schedule(1) 
        Atm2 = self%schedule(2) 
        Atm3 = self%schedule(3) 
    else
        Atm1 = regrowOrder(nType, 2) 
        Atm2 = regrowOrder(nType, 1) 
        Atm3 = regrowOrder(nType, 3) 
    endif
    v1(1) = disp(Atm1)%x_new - disp(Atm2)%x_new
    v1(2) = disp(Atm1)%y_new - disp(Atm2)%y_new
    v1(3) = disp(Atm1)%z_new - disp(Atm2)%z_new
    call FindBond(nType, Atm2, Atm3, bondType)
    call FindAngle(nType, Atm1, Atm2, Atm3, angleType)
    do iRosen = 1, nRosenTrials(nType)
      call BondData(bondType) % bondFF % GenerateDist(trialBox%beta,r2, prob)
      call AngleData(angleType) % angleFF % GenerateDist(trialBox%beta, bond_ang, prob)
      call Generate_UnitCone(v1, r2, bond_ang, v2)
      self%tempcoords(1, iRosen) = v2(1) + disp(Atm2)%x_new
      self%tempcoords(2, iRosen) = v2(2) + disp(Atm2)%y_new
      self%tempcoords(3, iRosen) = v2(3) + disp(Atm2)%z_new
    enddo
!      E_Max = minval(E_Trial)
!      ProbRosen = 0d0
!      do iRosen = 1, nRosenTrials(nType)
!        ProbRosen(iRosen) = exp(-beta*(E_Trial(iRosen)-E_Max))         
!      enddo
!      if(all(ProbRosen .le. 0d0)) then
!        rejMove = .true.
!        return
!      endif

      nRegrown = 3
      do while(nRegrown < nAtoms)
        nRegrown = nRegrown + 1
        atm4 = regrowOrder(nType, nRegrown) 
        call FindAtomsFromPath(nType, regrown, 1, Atm4, Atm1, Atm2, Atm3)
        call FindBond(nType, Atm3, Atm4, bondType)
        k_bond = bondData(bondType)%k_eq
        r_eq = bondData(bondType)%r_eq
        call FindAngle(nType, Atm2, Atm3, Atm4, bendType)
        call FindTorsion(nType, Atm1, Atm2, Atm3, Atm4, torsType)
        v1%x = newMol%x(Atm1) - newMol%x(Atm3)
        v1%y = newMol%y(Atm1) - newMol%y(Atm3)
        v1%z = newMol%z(Atm1) - newMol%z(Atm3)

        v2%x = newMol%x(Atm2) - newMol%x(Atm3)
        v2%y = newMol%y(Atm2) - newMol%y(Atm3)
        v2%z = newMol%z(Atm2) - newMol%z(Atm3)
        overlap = .false.
        E_Trial = 0d0
        do iRosen = 1, nRosenTrials(nType)
          call BondData(bondType) % bondFF % GenerateDist(trialBox%beta,r2, prob)
          call AngleData(angleType) % angleFF % GenerateDist(trialBox%beta, bond_ang, prob)
          call GenerateBondLength(r, k_bond, r_eq, Prob)
          call GenerateBendAngle(bend_angle, bendType, Prob)
          call GenerateTorsAngle(tors_angle, torsType, Prob)
          call Generate_UnitTorsion(v1, v2, r, bend_angle, tors_angle, v3)
          trialPos(iRosen)%x = v3%x + newMol%x(Atm3) 
          trialPos(iRosen)%y = v3%y + newMol%y(Atm3)
          trialPos(iRosen)%z = v3%z + newMol%z(Atm3)
          call Rosen_BoltzWeight_Atom_New(nType, Atm4, trialPos(iRosen), isIncluded,  E_Trial(iRosen), overlap(iRosen))
        enddo
        E_Max = minval(E_Trial)
        ProbRosen = 0d0
        do iRosen = 1, nRosenTrials(nType)
          ProbRosen(iRosen) = exp(-beta*(E_Trial(iRosen)-E_Max))         
        enddo
!        if(all(ProbRosen .le. 0d0)) then
!          rejMove = .true.
!          return
!        endif
        rosenNorm = sum(ProbRosen)
        ranNum = grnd() * rosenNorm
        sumInt = ProbRosen(1)
        nSel = 1
        do while(sumInt .lt. ranNum)
          nSel = nSel + 1
          sumInt = sumInt + ProbRosen(nSel)
        enddo
        if(overlap(nSel) .eqv. .true.) then
          rejMove = .true.
          return
        endif
        rosenRatio = rosenRatio*ProbRosen(nSel)*dble(nRosenTrials(nType))/rosenNorm
        regrown(Atm4) = .true.
        nRegrown = nRegrown + 1
        newMol%x(Atm4) = trialPos(nSel)%x 
        newMol%y(Atm4) = trialPos(nSel)%y 
        newMol%z(Atm4) = trialPos(nSel)%z
      enddo

      if(overlap(nSel) .eqv. .true.) then
        rejMove = .true.
        return
      endif
      rosenRatio = rosenRatio*ProbRosen(nSel)*dble(nRosenTrials(nType))/rosenNorm
      regrown(Atm3) = .true.
      nRegrown = nRegrown + 1



  end subroutine
!======================================================================================
  subroutine LinearCBMC_ReverseConfig(self, trialBox, probconstruct, accept)
    implicit none
    class(LinearCBMC), intent(inout) :: self
!    class(Perturbation), intent(inout) :: disp(:)
    class(SimBox), intent(inout) :: trialBox
    real(dp), intent(out) :: probconstruct 
    logical, intent(out) :: accept

    accept = .true.
    probconstruct = 1E0_dp
  end subroutine
!==========================================================================================
  subroutine LinearCBMC_GasConfig(self,  probGas)
    implicit none
    class(MolConstructor), intent(inout) :: self
    real(dp), intent(out) :: probGas


    probGas = 1E0_dp
  end subroutine
!==========================================================================================
end module
!==========================================================================================
